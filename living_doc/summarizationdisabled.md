- **予算とSummarization の分岐**  `chat.summarizeAgentConversationHistory.enabled` は常に true（[src/platform/configuration/common/configurationService.ts#L889-L897](src/platform/configuration/common/configurationService.ts#L889-L897)）ですが、false にした状態でも `AgentIntentInvocation` は `SummarizeAgentConversationHistoryThreshold`（[src/platform/configuration/common/configurationService.ts#L656-L673](src/platform/configuration/common/configurationService.ts#L656-L673)）を使ってツールトークンを差し引き、85% の余裕を持たせた `safeBudget` を計算後に `PromptRenderer` で一度だけレンダリングします。`BudgetExceededError` の catch ブロックでは summarization（`triggerSummarize`）を走らせるのは `summarizationEnabled`（設定 + `AgentPrompt`）が true の場合のみで、false なら例外をそのまま投げるか最終的に `PromptRenderer` の自動的なトークン剪定に依存します（[src/extension/intents/node/agentIntent.ts#L221-L315](src/extension/intents/node/agentIntent.ts#L221-L315)）。

- **prompt-tsx の Pruning 機構と AgentPrompt による仕込み**  prompt-tsx は各要素に `priority` を持たせ、トークン超過時に priority の低いメッセージから順に落とすので、任意のコンテンツを安全に積み上げられます（[node_modules/@vscode/prompt-tsx/README.md#L18-L24](node_modules/@vscode/prompt-tsx/README.md#L18-L24)）。`AgentPrompt` 側では、キャッシュなしルートで `AgentConversationHistory`＋`AgentUserMessage`＋`ChatToolCalls` を `flexGrow`/`priority` を掛け合わせて組み立て、ツール結果は `MAX_TOOL_RESPONSE_PCT=0.5` で `truncateAt`、作業環境情報やワークスペース構造は `TokenLimit max={2000}` で硬い上限、`ChatVariables` 周囲も `TokenLimit max={sizing.tokenBudget / 6}` として大きくなりすぎないよう制限しています（[src/extension/prompts/node/agent/agentPrompt.tsx#L118-L372](src/extension/prompts/node/agent/agentPrompt.tsx#L118-L372)、[src/extension/prompts/node/agent/agentConversationHistory.tsx#L11-L81](src/extension/prompts/node/agent/agentConversationHistory.tsx#L11-L81)）。`PrioritizedList` や `TokenLimit` によって「後ろの履歴」や副次情報から順に落として、`PromptRenderer` のプライオリティ付き pruning と組み合わせてコンテキストウィンドウ内に収めています。

- **履歴のトリミング量とキャッシュヒット率**  `cacheBreakpoints.ts` で「ツール結果→ユーザー→履歴」の順に最大 4 つのキャッシュ境界を入れて毎ターンヒットを狙う設計になっており（[src/extension/intents/node/cacheBreakpoints.ts#L11-L35](src/extension/intents/node/cacheBreakpoints.ts#L11-L35)）、`living_doc/cachehit.md` でもこの仕組みを前提に「summarization ありなら追加 breakpoints、なしなら stripping して fallback する」書き方になっており、1 回で落ちる履歴の量を少し変えてもキャッシュ境界がズレるとヒット率が下がることを強調しています（[living_doc/cachehit.md#L8-L11](living_doc/cachehit.md#L8-L11)）。つまり履歴のトリミング量は単にトークン節約以上に、breakpoint による再利用パターンを維持するために細心の注意が必要です。

次のアクション候補:
1. `summarizedConversationHistory` か `response.success` の telemetry で `promptCacheTokenCount` を観察し、summarization を切った状態で落とした履歴がヒットにどう影響しているかを確認。
2. `AgentHistorySummarizationWithPromptCache` をオン/オフして `addCacheBreakpoints` の挙動と fallback 周り（`cacheBreakpoints` の境界が維持されるか）をデバッグして、trim の量がホストキャッシュにどう跳ね返るかを見る。
